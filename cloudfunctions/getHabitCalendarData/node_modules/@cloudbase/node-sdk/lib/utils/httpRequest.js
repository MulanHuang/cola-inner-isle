"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const http_1 = __importDefault(require("http"));
const tracing_1 = require("./tracing");
const utils = __importStar(require("./utils"));
const code_1 = require("../const/code");
const symbol_1 = require("../const/symbol");
const cloudbase_1 = require("../cloudbase");
const request_1 = require("./request");
const requestHook_1 = require("./requestHook");
const wxCloudToken_1 = require("./wxCloudToken");
const signature_nodejs_1 = require("@cloudbase/signature-nodejs");
const url_1 = __importDefault(require("url"));
// import { version } from '../../package.json'
const secretManager_1 = __importDefault(require("./secretManager"));
const { version } = require('../../package.json');
const { E, second, processReturn, getServerInjectUrl } = utils;
class Request {
    constructor(args) {
        this.urlPath = '/admin';
        this.defaultTimeout = 15000;
        this.timestamp = new Date().valueOf();
        this.tracingInfo = tracing_1.generateTracingInfo();
        this.slowWarnTimer = null;
        // è¯·æ±‚å‚æ•°
        this.hooks = {};
        this.args = args;
        this.config = args.config;
        this.opts = args.opts || {};
        this.secretManager = new secretManager_1.default();
    }
    /**
     * æœ€ç»ˆå‘é€è¯·æ±‚
     */
    async request() {
        // æ ¡éªŒå¯†é’¥æ˜¯å¦å­˜åœ¨
        await this.validateSecretIdAndKey();
        // æ„é€ è¯·æ±‚å‚æ•°
        const params = await this.makeParams();
        const opts = await this.makeReqOpts(params);
        const action = this.getAction();
        const key = {
            functions: 'function_name',
            database: 'collectionName',
            wx: 'apiName'
        }[action.split('.')[0]];
        const argopts = this.opts;
        const config = this.config;
        // å‘è¯·æ±‚æ—¶æœªæ‰¾åˆ°æœ‰æ•ˆç¯å¢ƒå­—æ®µ
        if (!params.envName) {
            // æ£€æŸ¥configä¸­æ˜¯å¦æœ‰è®¾ç½®
            if (config.envName) {
                return processReturn(config.throwOnCode, Object.assign({}, code_1.ERROR.INVALID_PARAM, { message: 'æœªå–åˆ°init æŒ‡å®š envï¼' }));
            }
            else {
                console.warn(`å½“å‰æœªæŒ‡å®šenvï¼Œå°†é»˜è®¤ä½¿ç”¨ç¬¬ä¸€ä¸ªåˆ›å»ºçš„ç¯å¢ƒï¼`);
            }
        }
        // æ³¨æ„ï¼šå¿…é¡»åˆå§‹åŒ–ä¸º null
        let retryOptions = null;
        if (argopts.retryOptions) {
            retryOptions = argopts.retryOptions;
        }
        else if (config.retries && typeof config.retries === 'number') {
            retryOptions = { retries: config.retries };
        }
        return request_1.extraRequest(opts, {
            debug: config.debug,
            op: `${action}:${this.args.params[key]}@${params.envName}`,
            seqId: this.getSeqId(),
            retryOptions: retryOptions,
            timingsMeasurerOptions: config.timingsMeasurerOptions || {}
        }).then((response) => {
            this.slowWarnTimer && clearTimeout(this.slowWarnTimer);
            const { body } = response;
            if (response.statusCode === 200) {
                let res;
                try {
                    res = typeof body === 'string' ? JSON.parse(body) : body;
                    if (this.hooks && this.hooks.handleData) {
                        res = this.hooks.handleData(res, null, response, body);
                    }
                }
                catch (e) {
                    res = body;
                }
                return res;
            }
            else {
                const e = E({
                    code: response.statusCode,
                    message: ` ${response.statusCode} ${http_1.default.STATUS_CODES[response.statusCode]} | [${opts.url}]`
                });
                throw e;
            }
        });
    }
    setHooks(hooks) {
        Object.assign(this.hooks, hooks);
    }
    getSeqId() {
        return this.tracingInfo.seqId;
    }
    /**
     * æ¥å£action
     */
    getAction() {
        const { params } = this.args;
        const { action } = params;
        return action;
    }
    /**
     * è®¾ç½®è¶…æ—¶warning
     */
    setSlowWarning(timeout) {
        const action = this.getAction();
        const { seqId } = this.tracingInfo;
        this.slowWarnTimer = setTimeout(() => {
            /* istanbul ignore next */
            const msg = `Your current request ${action ||
                ''} is longer than 3s, it may be due to the network or your query performance | [${seqId}]`;
            /* istanbul ignore next */
            console.warn(msg);
        }, timeout);
    }
    /**
     * æ„é€ params
     */
    async makeParams() {
        const { TCB_SESSIONTOKEN, TCB_ENV, SCF_NAMESPACE } = cloudbase_1.CloudBase.getCloudbaseContext();
        const args = this.args;
        const opts = this.opts;
        const config = this.config;
        const { eventId } = this.tracingInfo;
        const crossAuthorizationData = opts.getCrossAccountInfo && (await opts.getCrossAccountInfo()).authorization;
        const { wxCloudApiToken, wxCloudbaseAccesstoken } = wxCloudToken_1.getWxCloudToken();
        const params = Object.assign({}, args.params, { envName: config.envName, eventId,
            wxCloudApiToken,
            wxCloudbaseAccesstoken, tcb_sessionToken: TCB_SESSIONTOKEN || '', sessionToken: config.sessionToken, crossAuthorizationToken: crossAuthorizationData
                ? Buffer.from(JSON.stringify(crossAuthorizationData)).toString('base64')
                : '' });
        // å–å½“å‰äº‘å‡½æ•°ç¯å¢ƒæ—¶ï¼Œæ›¿æ¢ä¸ºäº‘å‡½æ•°ä¸‹ç¯å¢ƒå˜é‡
        if (params.envName === symbol_1.SYMBOL_CURRENT_ENV) {
            params.envName = TCB_ENV || SCF_NAMESPACE;
        }
        // è¿‡æ»¤value undefined
        utils.filterUndefined(params);
        return params;
    }
    /**
     *  æ„é€ è¯·æ±‚é¡¹
     */
    async makeReqOpts(params) {
        const config = this.config;
        const args = this.args;
        const isInternal = await utils.checkIsInternalAsync();
        const url = this.getUrl({ isInternal });
        const method = this.getMethod();
        const opts = {
            url: url,
            method,
            // å…ˆå–æ¨¡å—çš„timeoutï¼Œæ²¡æœ‰åˆ™å–sdkçš„timeoutï¼Œè¿˜æ²¡æœ‰å°±ä½¿ç”¨é»˜è®¤å€¼
            // timeout: args.timeout || config.timeout || 15000,
            timeout: this.getTimeout(),
            // ä¼˜å…ˆå–configï¼Œå…¶æ¬¡å–æ¨¡å—ï¼Œæœ€åå–é»˜è®¤
            headers: await this.getHeaders(url),
            proxy: config.proxy
        };
        opts.keepalive = config.keepalive === true;
        if (args.method === 'post') {
            if (args.isFormData) {
                opts.formData = params;
                opts.encoding = null;
            }
            else {
                opts.body = params;
                opts.json = true;
            }
        }
        else {
            /* istanbul ignore next */
            opts.qs = params;
        }
        return opts;
    }
    /**
     * åè®®
     */
    getProtocol() {
        return this.config.isHttp === true ? 'http' : 'https';
    }
    /**
     * è¯·æ±‚æ–¹æ³•
     */
    getMethod() {
        return this.args.method || 'get';
    }
    /**
     * è¶…æ—¶æ—¶é—´
     */
    getTimeout() {
        const { opts = {} } = this.args;
        // timeoutä¼˜å…ˆçº§ è‡ªå®šä¹‰æ¥å£timeout > configé…ç½®timeout > é»˜è®¤timeout
        return opts.timeout || this.config.timeout || this.defaultTimeout;
    }
    /**
     * æ ¡éªŒå¯†é’¥å’Œtokenæ˜¯å¦å­˜åœ¨
     */
    async validateSecretIdAndKey() {
        const { TENCENTCLOUD_SECRETID, TENCENTCLOUD_SECRETKEY, TENCENTCLOUD_SESSIONTOKEN } = cloudbase_1.CloudBase.getCloudbaseContext(); // æ”¾åœ¨æ­¤å¤„æ˜¯ä¸ºäº†å…¼å®¹æœ¬åœ°ç¯å¢ƒä¸‹è¯»ç¯å¢ƒå˜é‡
        const isInSCF = utils.checkIsInScf();
        const isInContainer = utils.checkIsInEks();
        let opts = this.opts;
        let getCrossAccountInfo = opts.getCrossAccountInfo || this.config.getCrossAccountInfo;
        /* istanbul ignore if  */
        if (getCrossAccountInfo) {
            let crossAccountInfo = await getCrossAccountInfo();
            let { credential } = await getCrossAccountInfo();
            let { secretId, secretKey, token } = credential || {};
            this.config = Object.assign({}, this.config, { secretId,
                secretKey, sessionToken: token });
            this.opts.getCrossAccountInfo = () => Promise.resolve(crossAccountInfo);
            if (!this.config.secretId || !this.config.secretKey) {
                throw E(Object.assign({}, code_1.ERROR.INVALID_PARAM, { message: 'missing secretId or secretKey of tencent cloud' }));
            }
        }
        else {
            const { secretId, secretKey } = this.config;
            if (!secretId || !secretKey) {
                /* istanbul ignore if  */
                if (isInContainer) {
                    // è¿™ç§æƒ…å†µæœ‰å¯èƒ½æ˜¯åœ¨å®¹å™¨å†…ï¼Œæ­¤æ—¶å°è¯•æ‹‰å–ä¸´æ—¶
                    const tmpSecret = await this.secretManager.getTmpSecret();
                    this.config = Object.assign({}, this.config, { secretId: tmpSecret.id, secretKey: tmpSecret.key, sessionToken: tmpSecret.token });
                    return;
                }
                if (!TENCENTCLOUD_SECRETID || !TENCENTCLOUD_SECRETKEY) {
                    if (isInSCF) {
                        throw E(Object.assign({}, code_1.ERROR.INVALID_PARAM, { message: 'missing authoration key, redeploy the function' }));
                    }
                    else {
                        throw E(Object.assign({}, code_1.ERROR.INVALID_PARAM, { message: 'missing secretId or secretKey of tencent cloud' }));
                    }
                }
                else {
                    this.config = Object.assign({}, this.config, { secretId: TENCENTCLOUD_SECRETID, secretKey: TENCENTCLOUD_SECRETKEY, sessionToken: TENCENTCLOUD_SESSIONTOKEN });
                }
            }
        }
    }
    /**
     *
     * è·å–headers æ­¤å‡½æ•°ä¸­è®¾ç½®authorization
     */
    async getHeaders(url) {
        const config = this.config;
        const { secretId, secretKey } = config;
        const args = this.args;
        const method = this.getMethod();
        const { TCB_SOURCE } = cloudbase_1.CloudBase.getCloudbaseContext();
        // Note: äº‘å‡½æ•°è¢«è°ƒç”¨æ—¶å¯èƒ½è°ƒç”¨ç«¯æœªä¼ é€’ SOURCEï¼ŒTCB_SOURCE å¯èƒ½ä¸ºç©º
        const SOURCE = utils.checkIsInScf() ? `${TCB_SOURCE || ''},scf` : ',not_scf';
        let requiredHeaders = {
            'User-Agent': `tcb-node-sdk/${version}`,
            'x-tcb-source': SOURCE,
            'x-client-timestamp': this.timestamp,
            'X-SDK-Version': `tcb-node-sdk/${version}`,
            Host: url_1.default.parse(url).host
        };
        if (config.version) {
            requiredHeaders['X-SDK-Version'] = config.version;
        }
        if (this.tracingInfo.trace) {
            requiredHeaders['x-tcb-tracelog'] = this.tracingInfo.trace;
        }
        const region = this.config.region || process.env.TENCENTCLOUD_REGION || '';
        if (region) {
            requiredHeaders['X-TCB-Region'] = region;
        }
        requiredHeaders = Object.assign({}, config.headers, args.headers, requiredHeaders);
        const { authorization, timestamp } = signature_nodejs_1.sign({
            secretId: secretId,
            secretKey: secretKey,
            method: method,
            url: url,
            params: await this.makeParams(),
            headers: requiredHeaders,
            withSignedParams: true,
            timestamp: second() - 1
        });
        requiredHeaders['Authorization'] = authorization;
        requiredHeaders['X-Signature-Expires'] = 600;
        requiredHeaders['X-Timestamp'] = timestamp;
        return Object.assign({}, requiredHeaders);
    }
    /**
     * è·å–url
     * @param action
     */
    /* eslint-disable-next-line complexity */
    getUrl(options = {
        isInternal: false
    }) {
        if (utils.checkIsInScf()) {
            // äº‘å‡½æ•°ç¯å¢ƒä¸‹ï¼Œåº”è¯¥åŒ…å«ä»¥ä¸‹ç¯å¢ƒå˜é‡ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåç»­é€»è¾‘å¯èƒ½ä¼šæœ‰é—®é¢˜
            if (!process.env.TENCENTCLOUD_REGION) {
                console.error('[ERROR] missing `TENCENTCLOUD_REGION` environment');
            }
            if (!process.env.SCF_NAMESPACE) {
                console.error('[ERROR] missing `SCF_NAMESPACE` environment');
            }
        }
        const { TCB_ENV, SCF_NAMESPACE } = cloudbase_1.CloudBase.getCloudbaseContext();
        // ä¼˜å…ˆçº§ï¼šç”¨æˆ·é…ç½® > ç¯å¢ƒå˜é‡
        const region = this.config.region || process.env.TENCENTCLOUD_REGION || '';
        // æœ‰åœ°åŸŸä¿¡æ¯åˆ™è®¿é—®åœ°åŸŸçº§åˆ«åŸŸåï¼Œæ— åœ°åŸŸä¿¡æ¯åˆ™è®¿é—®é»˜è®¤åŸŸåï¼Œé»˜è®¤åŸŸåå›ºå®šè§£æåˆ°ä¸Šæµ·åœ°åŸŸä¿æŒå…¼å®¹
        const internetRegionEndpoint = region
            ? `${region}.tcb-api.tencentcloudapi.com`
            : `tcb-api.tencentcloudapi.com`;
        const internalRegionEndpoint = region
            ? `internal.${region}.tcb-api.tencentcloudapi.com`
            : `internal.tcb-api.tencentcloudapi.com`;
        // åŒåœ°åŸŸèµ°å†…ç½‘ï¼Œè·¨åœ°åŸŸèµ°å…¬ç½‘
        const isSameRegionVisit = this.config.region
            ? this.config.region === process.env.TENCENTCLOUD_REGION
            : true;
        const endpoint = isSameRegionVisit && (options.isInternal)
            ? internalRegionEndpoint
            : internetRegionEndpoint;
        const envName = this.config.envName || '';
        const currEnv = TCB_ENV || SCF_NAMESPACE || '';
        // æ³¨æ„ï¼šç‰¹æ®Šç¯å¢ƒIDä¸èƒ½æ‹¼åœ¨è¯·æ±‚åœ°å€çš„åŸŸåä¸­ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦ç‰¹æ®Šå¤„ç†
        const envId = envName === symbol_1.SYMBOL_CURRENT_ENV || utils.isPageModuleName(envName)
            ? currEnv
            : envName;
        const envEndpoint = utils.isValidEnvFormat(envId) ? `${envId}.${endpoint}` : endpoint;
        const protocol = options.isInternal ? 'http' : this.getProtocol();
        // æ³¨æ„ï¼šäº‘å‡½æ•°ç¯å¢ƒä¸‹æœ‰åœ°åŸŸä¿¡æ¯ï¼Œäº‘åº”ç”¨ç¯å¢ƒä¸‹ä¸ç¡®å®šæ˜¯å¦æœ‰ï¼Œå¦‚æœæ²¡æœ‰ï¼Œç”¨æˆ·å¿…é¡»æ˜¾å¼çš„ä¼ å…¥
        const defaultUrl = `${protocol}://${envEndpoint}${this.urlPath}`;
        const { eventId, seqId } = this.tracingInfo;
        const { serviceUrl } = this.config;
        const serverInjectUrl = getServerInjectUrl();
        const url = serviceUrl || serverInjectUrl || defaultUrl;
        const qs = cloudbase_1.CloudBase.scfContext
            ? `&eventId=${eventId}&seqId=${seqId}&scfRequestId=${cloudbase_1.CloudBase.scfContext.requestId}`
            : `&eventId=${eventId}&seqId=${seqId}`;
        return url.includes('?') ? `${url}${qs}` : `${url}?${qs}`;
    }
}
exports.Request = Request;
// ä¸šåŠ¡é€»è¾‘éƒ½æ”¾åœ¨è¿™é‡Œå¤„ç†
exports.default = async (args) => {
    const req = new Request(args);
    const config = args.config;
    const { action } = args.params;
    if (action === 'wx.openApi' || action === 'wx.wxPayApi') {
        req.setHooks({ handleData: requestHook_1.handleWxOpenApiData });
    }
    if (action.startsWith('database')) {
        req.setSlowWarning(3000);
    }
    try {
        const res = await req.request();
        // æ£€æŸ¥resæ˜¯å¦ä¸ºreturn {code, message}å›åŒ…
        if (res && res.code) {
            // åˆ¤æ–­æ˜¯å¦è®¾ç½®config._returnCodeByThrow = false
            return processReturn(config.throwOnCode, res);
        }
        return res;
    }
    finally {
        //
    }
};
