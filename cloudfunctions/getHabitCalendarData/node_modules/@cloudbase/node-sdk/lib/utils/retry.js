"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const retry_1 = __importDefault(require("retry"));
// import { RetryOperation } from 'retry/lib/retry_operation'
const RetryOperation = require('retry/lib/retry_operation');
/* istanbul ignore next */
function defaultShouldRetry(e, result) {
    return { retryAble: false, message: '' };
}
/**
 * withRetry é‡è¯•å°è£…å‡½æ•°
 * @param fn
 * @param retryOptions
 */
/* istanbul ignore next */
function withRetry(fn, retryOptions) {
    // é»˜è®¤ä¸é‡è¯•ï¼Œ0 è¡¨è¾¾æœªå¼€å¯çš„å«ä¹‰ï¼Œæ‰€ä»¥ç›´æŽ¥è¿”å›ž promise
    if (!retryOptions || retryOptions.retries === 0) {
        return fn();
    }
    // é»˜è®¤é‡è¯•ç­–ç•¥é‡‡å–æŒ‡æ•°é€€é¿ç­–ç•¥ï¼Œè¶…æ—¶æ—¶é—´è®¡ç®—å…¬å¼åŠå‚æ•°å¯æŸ¥æ–‡æ¡£
    // https://github.com/tim-kos/node-retry/
    // è‡ªå®šé‡è¯•æ—¶é—´ï¼š
    // timeouts: [1000, 2000, 4000, 8000]
    const timeouts = retryOptions.timeouts
        ? [...retryOptions.timeouts]
        : retry_1.default.timeouts(retryOptions);
    const operation = new RetryOperation(timeouts, {
        forever: retryOptions.forever,
        unref: retryOptions.unref,
        maxRetryTime: retryOptions.maxRetryTime // é‡è¯•æ€»çš„æ—¶é—´ï¼Œå•ä½æ¯«ç§’ï¼Œé»˜è®¤ï¼šInfinity
    });
    const shouldRetry = retryOptions.shouldRetry || defaultShouldRetry;
    return new Promise((resolve, reject) => {
        const isReadyToRetry = (e, resp, operation) => {
            // å¤–å±‚æœ‰æ•ˆè¯†åˆ«éœ€è¦æˆ–è€…èƒ½å¤Ÿè¿›è¡Œé‡è¯•
            // shouldRetry ä¸­å¯è°ƒç”¨ operation.stop åœæŽ‰é‡è¯•ï¼Œoperation.retry è¿”å›ž false
            const { retryAble, message } = shouldRetry(e, resp, operation);
            const info = {};
            info.nth = operation.attempts();
            info.at = new Date();
            info.message = message;
            // åŒé‡æ¡ä»¶åˆ¤æ–­æ˜¯å¦é‡è¯•ï¼Œå¤–å±‚åˆ¤æ–­æ»¡è¶³æ¡ä»¶ä¸Žå¦ï¼Œè¿˜éœ€åˆ¤æ–­æ˜¯å¦æ»¡è¶³å†æ¬¡é‡è¯•æ¡ä»¶
            const readyToRetry = retryAble && operation.retry(Object.assign({}, info));
            if (!readyToRetry) {
                // å¦‚æžœä¸å‡†å¤‡è¿›è¡Œé‡è¯•ï¼Œå¹¶ä¸”å°è¯•ä¸æ­¢ä¸€æ¬¡
                // æœ€åŽä¸€ä¸ªé”™è¯¯è®°å½•é‡è¯•ä¿¡æ¯
                const ref = e || resp;
                if (ref && operation.attempts() > 1) {
                    ref.attempt = {};
                    ref.attempt.timeouts = operation._originalTimeouts;
                    ref.attempt.attempts = operation.attempts();
                    ref.attempt.errors = operation.errors();
                    // å¦‚æžœæœ€åŽä¸€æ¬¡å› ä¸º !retryAble è€Œæ²¡æœ‰è¿›è¡Œé‡è¯•
                    // ref.attempt.errors ä¸­å°†ç¼ºå°‘æœ€åŽçš„è¿™ä¸ªé”™è¯¯
                    // ref.attempt.errors ä¸­åŒ…å«æœ€åŽä¸€æ¬¡é”™è¯¯ä¿¡æ¯
                    if (!retryAble) {
                        ref.attempt.errors.push(info);
                    }
                }
            }
            return readyToRetry;
        };
        operation.attempt(async () => {
            try {
                const result = await fn(operation.attempts());
                if (!isReadyToRetry(null, result, operation)) {
                    resolve(result);
                }
            }
            catch (e) {
                try {
                    if (!isReadyToRetry(e, null, operation)) {
                        reject(e);
                    }
                }
                catch (e) {
                    reject(e);
                }
            }
        }, retryOptions.timeoutOps);
    });
}
exports.withRetry = withRetry;
