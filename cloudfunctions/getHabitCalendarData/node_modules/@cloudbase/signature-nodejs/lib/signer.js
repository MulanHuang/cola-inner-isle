"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const utils_1 = require("./utils");
const utils_lang_1 = require("./utils.lang");
const keyvalue_1 = require("./keyvalue");
const url_1 = require("url");
const debug = require('util').debuglog('@cloudbase/signature');
const isStream = require('is-stream');
exports.signedParamsSeparator = ';';
const HOST_KEY = 'host';
const CONTENT_TYPE_KEY = 'content-type';
var MIME;
(function (MIME) {
    MIME["MULTIPART_FORM_DATA"] = "multipart/form-data";
    MIME["APPLICATION_JSON"] = "application/json";
})(MIME || (MIME = {}));
class Signer {
    constructor(credential, service, options = {}) {
        this.credential = credential;
        this.service = service;
        this.algorithm = 'TC3-HMAC-SHA256';
        this.options = options;
    }
    static camSafeUrlEncode(str) {
        return encodeURIComponent(str)
            .replace(/!/g, '%21')
            .replace(/'/g, '%27')
            .replace(/\(/g, '%28')
            .replace(/\)/g, '%29')
            .replace(/\*/g, '%2A');
    }
    /**
     * å°†ä¸€ä¸ªå¯¹è±¡å¤„ç†æˆ KeyValue å½¢å¼ï¼ŒåµŒå¥—çš„å¯¹è±¡å°†ä¼šè¢«å¤„ç†æˆå­—ç¬¦ä¸²ï¼ŒKeyè½¬æ¢æˆå°å†™å­—æ¯
     * @param {Object}  obj - å¾…å¤„ç†çš„å¯¹è±¡
     * @param {Object}  options
     * @param {Boolean} options.enableBuffer
     */
    static formatKeyAndValue(obj, options = {}) {
        if (!utils_lang_1.isPlainObject(obj)) {
            return obj;
        }
        // enableValueToLowerCaseï¼šå¤´éƒ¨å­—æ®µï¼Œè¦æ±‚å°å†™ï¼Œå…¶ä»–æ•°æ®ä¸éœ€è¦å°å†™ï¼Œæ‰€ä»¥è¿™é‡Œé¿å…è½¬å°å†™
        const { multipart, enableValueToLowerCase = false, selectedKeys, filter } = options;
        const kv = {};
        Object.keys(obj || {}).forEach(key => {
            // NOTE: å®¢æˆ·ç«¯ç±»å‹åœ¨æœåŠ¡ç«¯å¯èƒ½ä¼šä¸¢å¤±
            const lowercaseKey = Signer.camSafeUrlEncode(key.toLowerCase().trim());
            // è¿‡æ»¤ Keyï¼ŒæœåŠ¡ç«¯æ¥æ”¶åˆ°çš„æ•°æ®ï¼Œå¯èƒ½å«æœ‰æœªç­¾åçš„ Keyï¼Œé€šå¸¸æ˜¯ç­¾åçš„æ—¶å€™è¢«è¿‡æ»¤æ‰çš„æµï¼Œæ•°æ®é‡å¯èƒ½ä¼šæ¯”è¾ƒå¤§
            // æ‰€ä»¥è¿™é‡Œæä¾›ä¸€ä¸ªè¿‡æ»¤çš„åˆ¤æ–­ï¼Œé¿å…ä¸å¿…è¦çš„è®¡ç®—
            // istanbul ignore next
            if (Array.isArray(selectedKeys) && !selectedKeys.includes(lowercaseKey)) {
                return;
            }
            // istanbul ignore next
            if (typeof filter === 'function') {
                if (filter(key, obj[key], options)) {
                    return;
                }
            }
            // istanbul ignore else
            if (key && obj[key] !== undefined) {
                if (lowercaseKey === CONTENT_TYPE_KEY) {
                    // multipart/form-data; boundary=???
                    if (obj[key].startsWith(MIME.MULTIPART_FORM_DATA)) {
                        kv[lowercaseKey] = MIME.MULTIPART_FORM_DATA;
                    }
                    else {
                        kv[lowercaseKey] = obj[key];
                    }
                    return;
                }
                if (isStream(obj[key])) {
                    // è¿™é‡Œå¦‚æœæ˜¯ä¸ªæ–‡ä»¶æµï¼Œåœ¨å‘é€çš„æ—¶å€™å¯ä»¥è¯†åˆ«
                    // æœåŠ¡ç«¯æ¥æ”¶åˆ°æ•°æ®ä¹‹åä¼ åˆ°è¿™é‡Œåˆ¤æ–­ä¸å‡ºæ¥çš„
                    // æ‰€ä»¥ä¼šè¿›å…¥åè¾¹çš„é€»è¾‘
                    return;
                }
                else if (utils_1.isNodeEnv() && Buffer.isBuffer(obj[key])) {
                    if (multipart) {
                        kv[lowercaseKey] = obj[key];
                    }
                    else {
                        kv[lowercaseKey] = enableValueToLowerCase
                            ? utils_1.stringify(obj[key]).trim().toLowerCase()
                            : utils_1.stringify(obj[key]).trim();
                    }
                }
                else {
                    kv[lowercaseKey] = enableValueToLowerCase
                        ? utils_1.stringify(obj[key]).trim().toLowerCase()
                        : utils_1.stringify(obj[key]).trim();
                }
            }
        });
        return kv;
    }
    static calcParamsHash(params, keys = null, options = {}) {
        debug(params, 'calcParamsHash');
        if (utils_lang_1.isString(params)) {
            return utils_1.sha256hash(params);
        }
        // åªå…³å¿ƒä¸šåŠ¡å‚æ•°ï¼Œä¸å…³å¿ƒä»¥ä»€ä¹ˆç±»å‹çš„ Content-Type ä¼ é€’çš„
        // æ‰€ä»¥ application/json multipart/form-data è®¡ç®—æ–¹å¼æ˜¯ç›¸åŒçš„
        keys = keys || keyvalue_1.SortedKeyValue.kv(params).keys();
        const hash = crypto.createHash('sha256');
        for (const key of keys) {
            // istanbul ignore next
            if (!params[key]) {
                continue;
            }
            // istanbul ignore next
            if (isStream(params[key])) {
                continue;
            }
            // string && buffer
            hash.update(`&${key}=`);
            hash.update(params[key]);
            hash.update('\r\n');
        }
        return hash.digest(options.encoding || 'hex');
    }
    /**
     * è®¡ç®—ç­¾åä¿¡æ¯
     * @param {string} method       - Http Verbï¼šGET/get POST/post åŒºåˆ†å¤§å°å†™
     * @param {string} url          - åœ°å€ï¼šhttp://abc.org/api/v1?a=1&b=2
     * @param {Object} headers      - éœ€è¦ç­¾åçš„å¤´éƒ¨å­—æ®µ
     * @param {string} params       - è¯·æ±‚å‚æ•°
     * @param {number} [timestamp]  - ç­¾åæ—¶é—´æˆ³
     * @param {object} [options]    - å¯é€‰å‚æ•°
     */
    tc3sign(method, url, headers, params, timestamp, options = {}) {
        timestamp = timestamp || utils_1.second();
        const urlInfo = url_1.parse(url);
        const formatedHeaders = Signer.formatKeyAndValue(headers, {
            enableValueToLowerCase: true
        });
        const headerKV = keyvalue_1.SortedKeyValue.kv(formatedHeaders);
        const signedHeaders = headerKV.keys();
        const canonicalHeaders = headerKV.toString(':', '\n') + '\n';
        const { enableHostCheck = true, enableContentTypeCheck = true } = options;
        if (enableHostCheck && headerKV.get(HOST_KEY) !== urlInfo.host) {
            throw new TypeError(`host:${urlInfo.host} in url must be equals to host:${headerKV.get('host')} in headers`);
        }
        if (enableContentTypeCheck && !headerKV.get(CONTENT_TYPE_KEY)) {
            throw new TypeError(`${CONTENT_TYPE_KEY} field must in headers`);
        }
        const multipart = headerKV.get(CONTENT_TYPE_KEY).startsWith(MIME.MULTIPART_FORM_DATA);
        const formatedParams = method.toUpperCase() === 'GET' ? '' : Signer.formatKeyAndValue(params, {
            multipart
        });
        const paramKV = keyvalue_1.SortedKeyValue.kv(formatedParams);
        const signedParams = paramKV.keys();
        const hashedPayload = Signer.calcParamsHash(formatedParams, null);
        const signedUrl = url.replace(/^https?:/, '').split('?')[0];
        const canonicalRequest = `${method}\n${signedUrl}\n${urlInfo.query || ''}\n${canonicalHeaders}\n${signedHeaders.join(';')}\n${hashedPayload}`;
        debug(canonicalRequest, 'canonicalRequest\n\n');
        const date = utils_1.formateDate(timestamp);
        const service = this.service;
        const algorithm = this.algorithm;
        const credentialScope = `${date}/${service}/tc3_request`;
        const stringToSign = `${algorithm}\n${timestamp}\n${credentialScope}\n${utils_1.sha256hash(canonicalRequest)}`;
        debug(stringToSign, 'stringToSign\n\n');
        const secretDate = utils_1.sha256hmac(date, `TC3${this.credential.secretKey}`);
        const secretService = utils_1.sha256hmac(service, secretDate);
        const secretSigning = utils_1.sha256hmac('tc3_request', secretService);
        const signature = utils_1.sha256hmac(stringToSign, secretSigning, 'hex');
        debug(secretDate.toString('hex'), 'secretDate');
        debug(secretService.toString('hex'), 'secretService');
        debug(secretSigning.toString('hex'), 'secretSigning');
        debug(signature, 'signature');
        const { withSignedParams = false } = options;
        return {
            // éœ€æ³¨æ„è¯¥å­—æ®µé•¿åº¦
            // https://stackoverflow.com/questions/686217/maximum-on-http-header-values
            // https://www.tutorialspoint.com/What-is-the-maximum-size-of-HTTP-header-values
            authorization: `${algorithm} Credential=${this.credential.secretId}/${credentialScope},${withSignedParams ? ` SignedParams=${signedParams.join(';')},` : ''} SignedHeaders=${signedHeaders.join(';')}, Signature=${signature}`,
            signedParams,
            signedHeaders,
            signature,
            timestamp,
            multipart
        };
    }
}
exports.Signer = Signer;
